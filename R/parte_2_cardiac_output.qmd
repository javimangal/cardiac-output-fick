---
title: "Gasto cardíaco por ECOTT vs Fick"
subtitle: "Parte 2: Análisis principales Gasto Cardíaco"
author: 
  - "J. Mancilla Galindo, E. Garza Santiago, L.A. Fernández Urrutia"
  - "A. Kammar-García"
date: today
execute: 
  echo: false
  warning: false
format:
  pdf: 
    toc: false
    documentclass: scrartcl
  docx: 
    reference-doc: ../docs/manuscript/custom-reference-doc.docx
editor: source
bibliography: ../docs/manuscript/references.bib
csl: ../docs/manuscript/american-medical-association.csl
---

```{r}
#| include: false  

# Create directories for sub-folders  
inputfolder <- "../data/raw"
psfolder <- "../data/processed"
tempfolder <- "../data/temp"
figfolder <- "../results/output_figures"
tabfolder <- "../results/output_tables"

dir.create(inputfolder, showWarnings = FALSE)
dir.create(psfolder, showWarnings = FALSE)
dir.create(tempfolder, showWarnings = FALSE)
dir.create(figfolder, showWarnings = FALSE)
dir.create(tabfolder, showWarnings = FALSE)
```

```{r}
#| echo: false 

if (!require("pacman", quietly = TRUE)) {
  install.packages("pacman")
}

pacman::p_load(
  tidyverse,  # Used for basic data handling and visualization.
  dataverse,  # Retrieve dataset from the Harvard dataverse.
  table1,     # Used to add labels to variables.
  mgcv,       # Used to fit generalized additive models.
  lme4,       # Used to fit linear mixed effects models.
  irr,        # Used to calculate intraclass correlation coefficient.
  boot,       # Used to perform bootstrap.
  DHARMa,     # Used to simulate residuals for model diagnostics.
  lattice,    # Used to evaluate random effects.
  gridExtra,  # Used to arrange multiple plots.
  gt,         # Used to print html tables.  
  report      # Used to cite packages used in this session.   
)
```

```{r}
#| echo: false  

## Session and package dependencies

# remove clutter
session <- sessionInfo()
session$BLAS <- NULL
session$LAPACK <- NULL
session$loadedOnly <- NULL
# write log file
writeLines(
  capture.output(print(session, locale = FALSE)),
  paste0("sessions/",lubridate::today(), "_session_Part_2.txt")
)                                   # Change name to match your new .qmd file.
```

```{r}
# Load dataset from the dataverse
data_path <- get_file_by_name(
  filename = "cardiac_output_Fick_vs_ECOTT.RData",
  dataset = "10.7910/DVN/J4ONSU", 
  server = "dataverse.harvard.edu")

local_file <- paste0(tempfolder,"/cardiac_output_Fick_vs_ECOTT.RData")

writeBin(data_path, local_file)

load(local_file)
```

# Cardiac Output

The distribution of cardiac output values for both methods is skewed as shown bellow. 

```{r}
#| layout-ncol: 2
#| fig-cap: 
#|   - "TTE"
#|   - "Fick"

hist(
  data$cardiac_output_TTE,
  xlab = "Cardiac Output (TTE)",
  main = NULL
)

hist(
  data$cardiac_output_Fick,
  xlab = "Cardiac Output (Fick)",
  main = NULL
)
```

Thus, bootstrapping is used to calculate the mean with 95% CI: 

```{r}
# Obtain the mean and 95% CI for the mean
mean_boot <- function(data, indices) {
  sample_data <- data[indices]
  return(mean(sample_data))
}

# Perform bootstrapping for cardiac_output_TTE
set.seed(123)  # For reproducibility
boot_mean_CO_TTE <- boot(data = data$cardiac_output_TTE, statistic = mean_boot, R = 10000 )

# Calculate 95% CI using different methods from boot package
ci_basic_mean_CO_TTE <- boot.ci(boot_mean_CO_TTE, type = "basic")
ci_perc_mean_CO_TTE <- boot.ci(boot_mean_CO_TTE, type = "perc")
ci_bca_mean_CO_TTE <- boot.ci(boot_mean_CO_TTE, type = "bca")
```

```{r}
# Perform bootstrapping for cardiac_output_Fick
set.seed(123)  # For reproducibility
boot_mean_CO_Fick <- boot(data = data$cardiac_output_Fick, statistic = mean_boot, R = 10000 )

# Calculate 95% CI using different methods from boot package
ci_basic_mean_CO_Fick <- boot.ci(boot_mean_CO_Fick, type = "basic")
ci_perc_mean_CO_Fick <- boot.ci(boot_mean_CO_Fick, type = "perc")
ci_bca_mean_CO_Fick <- boot.ci(boot_mean_CO_Fick, type = "bca")
```

The mean cardiac output for TTE is `r mean(data$cardiac_output_TTE) %>% round(2)` L/min (95% CI: `r ci_bca_mean_CO_TTE$bca[4] %>% round(2)` to `r ci_bca_mean_CO_TTE$bca[5] %>% round(2)`), and for Fick, `r mean(data$cardiac_output_Fick) %>% round(2)` L/min (95% CI: `r ci_bca_mean_CO_Fick$bca[4] %>% round(2)` to `r ci_bca_mean_CO_Fick$bca[5] %>% round(2)`).

{{< pagebreak >}}

However, the distribution of differences between the two methods is approximately normal. 
```{r}
# Check for normal distribution of differences between cardiac output values (ECOTT - Fick)  

hist(
  data$cardiac_output_TTE - data$cardiac_output_Fick,
  xlab = "Difference in Cardiac Output (TTE - Fick)",
  main = NULL
)
```

```{r}
# Q-Q plot 
qqnorm(data$cardiac_output_TTE - data$cardiac_output_Fick)
```

\pagebreak

Assuming a linear and non-linear relationship

```{r}
ggplot(data, aes(x = cardiac_output_TTE, y = cardiac_output_Fick)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE, color = "red") +
  ylim(2, 16) +
  xlim(2, 16) +
  labs(
    x = "Cardiac Output (ECOTT)",
    y = "Cardiac Output (Fick)"
  ) +
  theme_classic()
```

```{r}
ggplot(data, aes(x = cardiac_output_TTE, y = cardiac_output_Fick)) +
  geom_point() +
  geom_smooth(method = "loess", color = "red") +
  ylim(2, 16) +
  xlim(2, 16) +
  labs(
    x = "Cardiac Output (ECOTT)",
    y = "Cardiac Output (Fick)"
  ) +
  theme_classic()
```

Examine if non-linear term is significantly better than linear term

```{r}
gam_model <- gam(cardiac_output_Fick ~ s(cardiac_output_TTE), data = data)

summary(gam_model)
```

```{r}
plot(gam_model, se = TRUE)
```

Non-linear relationship is not significantly better than linear relationship. Thus, I will model as linear relationship.

{{< pagebreak >}}

# Pearson correlation

```{r}
correlation <- cor.test(data$cardiac_output_TTE, data$cardiac_output_Fick, method = "pearson")
correlation
```

{{< pagebreak >}}

# Linear regression

```{r}
# Linear regression
linear_model <- lm(cardiac_output_TTE ~ cardiac_output_Fick, data = data)
summary(linear_model)
```

```{r}
# Plot residuals to check for patterns
plot(data$cardiac_output_Fick, residuals(linear_model), main = "Residuals vs Cardiac Output (Fick)", ylab = "Residuals", xlab = "Cardiac Output (Fick)")
abline(h = 0, col = "red", lty = 2)
```

{{< pagebreak >}}

# Linear Mixed Effects Model

```{r}
# Linear mixed effects model
linear_mixed_model <- lmer(
  cardiac_output_Fick ~ cardiac_output_TTE + (1 | ID) + (1 | time_point), 
  data = data
  )
```

```{r}
summary(linear_mixed_model)
```

Would it be relevant to study the effect of the observer on the cardiac output measurements?

```{r}
boxplot(
  cardiac_output_TTE ~ observer,
  data = data,
  main = "TTE Cardiac Output by Observer"
  )
```

Test if fixed or random effect is relevant in the model. 

```{r}
linear_mixed_model_obs_fixed <- lmer(
  cardiac_output_Fick ~ cardiac_output_TTE + observer + (1 | ID) + (1 | time_point),
  data = data
)
summary(linear_mixed_model_obs_fixed)
```

```{r}
linear_mixed_model_obs_random <- lmer(
  cardiac_output_Fick ~ cardiac_output_TTE + (1 | ID) + (1 | time_point) + (1 | observer),
  data = data
)
summary(linear_mixed_model_obs_random)
```

```{r}
anova(linear_mixed_model, linear_mixed_model_obs_fixed)
```

Fixed effect not statistically significant, and AIC decreases, whereas BIC does not. This suggests that the model fit does not improve importantly. I will re-check in Bland-Altman analysis if including observer would be relevant.

```{r}
anova(linear_mixed_model, linear_mixed_model_obs_random)  # For random effect
```

Random effect not relevant, as AIC and BIC do not improve, and model is not significantly better than the simpler model. 

```{r}
# 95% Confidence Intervals
linear_mixed_model_CI <- confint(linear_mixed_model_obs_fixed, level = 0.95)
```


{{< pagebreak >}}

# Intraclass correlation coefficient (ICC)

```{r}
# Calculate ICC
icc <- icc(
  data[, c("cardiac_output_TTE", "cardiac_output_Fick")], 
  model = "twoway", 
  type = "agreement", 
  unit = "single"
  )

icc
```

{{< pagebreak >}}

# Coefficient of variation (CV) and coefficient of error (CE)

The following calculation is the coefficient of variation (CV) for the overall averaged measurements, expressed as percentage:

```{r}
cv_Fick <- sd(data$cardiac_output_Fick) / mean(data$cardiac_output_Fick) * 100
```

Fick CV: `r cv_Fick %>% round(2)`%

```{r}
cv_TTE <- sd(data$cardiac_output_TTE) / mean(data$cardiac_output_TTE) * 100
```

TTE CV: `r cv_TTE %>% round(2)`%

Because there are multiple measurements that are averaged to produce the mean cardiac output for TTE, we can calculate the coefficient of error (CE) as suggested by Cecconi, et al.[@cecconi2009] The following calculations reproduce the structure of the table in their review article:

```{r}
# Calculate the standard deviation across the three measurements for each row
data$sd_CO_TTE <- apply(data %>% select(CO_TTE_1:CO_TTE_3), 1, sd)

# Calculate the coefficient of variation (CV) for repeated measurements per row
data$CV_TTE_CO_row <- data$sd_CO_TTE / data$cardiac_output_TTE * 100

# Calculate the coefficient of error
data$CE_TTE_CO <- data$CV_TTE_CO_row / sqrt(3)

# View the results
data %>% 
  select(ID, CO_TTE_1:CO_TTE_3, cardiac_output_TTE, 
         CV_TTE_CO_row, CE_TTE_CO, cardiac_output_Fick) %>% 
  head() %>% 
  mutate(across(-ID, ~round(., 2))) %>% 
  gt %>% 
  cols_label(
    CO_TTE_1 = "CO 1 (TTE), L/min",
    CO_TTE_2 = "CO 2 (TTE), L/min",
    CO_TTE_3 = "CO 3 (TTE), L/min",
    cardiac_output_TTE = "Mean CO TTE, L/min",
    CV_TTE_CO_row = "CV (%)",
    CE_TTE_CO = "CE (%)",
    cardiac_output_Fick = "CO (Fick method), L/min"
  ) %>% 
  # Adjust column sizes
  cols_width(
    ID ~ pct(10),
    CO_TTE_1:CO_TTE_3 ~ pct(10),
    cardiac_output_TTE ~ pct(20),
    CV_TTE_CO_row ~ pct(10),
    CE_TTE_CO ~ pct(10),
    cardiac_output_Fick ~ pct(20)
  ) %>%
  tab_footnote(
    footnote = "CE: Coefficient of Error; CV: Coefficient of Variation; TTE: Transthoracic Echocardiography."
  )

```

```{r}
# Obtain the mean and 95% CI for the coefficient of variation (CV) and error (CE)

# Perform bootstrapping for CV_TTE_CO_row
set.seed(123)  # For reproducibility
boot_CV <- boot(data = data$CV_TTE_CO_row, statistic = mean_boot, R = 10000 )

# Calculate 95% CI using different methods from boot package
ci_basic_CV <- boot.ci(boot_CV, type = "basic")
ci_perc_CV <- boot.ci(boot_CV, type = "perc")
ci_bca_CV <- boot.ci(boot_CV, type = "bca")
```

```{r}
# Perform bootstrapping for CE_TTE_CO
set.seed(123)  # For reproducibility
boot_CE <- boot(data = data$CE_TTE_CO, statistic = mean_boot, R = 10000 )

# Calculate 95% CI using different methods from boot package
ci_basic_CE <- boot.ci(boot_CE, type = "basic")
ci_perc_CE <- boot.ci(boot_CE, type = "perc")
ci_bca_CE <- boot.ci(boot_CE, type = "bca")
```

The mean CV of TTE for the repeated measurements per patient was `r mean(data$CV_TTE_CO_row) %>% round(1)`% (95% CI: `r ci_bca_CV$bca[4] %>% round(1)` to `r ci_bca_CV$bca[5] %>% round(1)`) and the CE was `r mean(data$CE_TTE_CO) %>% round(1)`% (95% CI: `r ci_bca_CE$bca[4] %>% round(1)` to `r ci_bca_CE$bca[5] %>% round(1)`), corresponding to a precision of `r (mean(data$CE_TTE_CO) * 2) %>% round(1)`% (95% CI: `r (ci_bca_CE$bca[4] * 2) %>% round(1)` to `r (ci_bca_CE$bca[5] * 2) %>% round(1)`).


{{< pagebreak >}}

# Bland-Altman Plot

#### Bland Altman-single measure

```{r}
# Calculate the mean and difference
data$mean_values <- (data$cardiac_output_TTE + data$cardiac_output_Fick) / 2
data$differences <- data$cardiac_output_TTE - data$cardiac_output_Fick

# Calculate mean and standard deviation of differences
mean_diff <- mean(data$differences, na.rm = TRUE)
sd_diff <- sd(data$differences, na.rm = TRUE)

# Plot using ggplot2
ggplot(data %>% mutate(`TTE Measurement` = "Mean Cardiac Output"),
       aes(x = mean_values, y = differences, color = `TTE Measurement`)) +
  geom_point(alpha = 0.5) +                             # Scatter plot of differences
  geom_hline(yintercept = mean_diff, color = "blue") +  # Mean difference line
  geom_hline(yintercept = mean_diff + 1.96 * sd_diff, linetype = "dashed", color = "red") +  # Upper limit
  geom_hline(yintercept = mean_diff - 1.96 * sd_diff, linetype = "dashed", color = "red") +  # Lower limit
  labs(
    title = "Bland-Altman Plot",
    x = "Mean of Cardiac Output (TTE and Fick)",
    y = "Difference Between Cardiac Output (TTE - Fick)"
  ) +
  scale_color_manual(values = c("Mean Cardiac Output" = "grey30")) +
  scale_x_continuous(limits = c(3.5, 13), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-10, 10.5), expand = c(0, 0)) +
  theme_minimal() +
  theme(
    legend.position = "bottom"
  )
```

##### Systematic bias (Paired t-test)

```{r}
# Paired t-test
t.test(data$cardiac_output_TTE, data$cardiac_output_Fick, paired = TRUE)
```

{{< pagebreak >}}

#### Bland Altman-repeated measures (random effects for between-subject variance)

```{r}
# Fit the linear mixed model
model <- lmer(differences ~ 1 + (1 | ID), data = data)
model_observer <- lmer(differences ~ 1 + (1 | ID) + observer, data = data)

anova(model, model_observer)
```

Despite not significantly improving the model, including observer as a fixed effect improved the distribution of observations around the mean, so this model was kept. 

```{r}
# Extract the fixed effect (mean difference) and random effects (within-subject variability)
mean_diff <- fixef(model_observer)[1]  # Mean difference
sd_diff <- sqrt(VarCorr(model_observer)$ID[1] + sigma(model_observer)^2)  # Total variability (within-subject + residual)

upper_limit <- mean_diff + 1.96 * sd_diff
lower_limit <- mean_diff - 1.96 * sd_diff
```

```{r}
summary(model_observer)
```

```{r}
# Create the Bland-Altman plot
fig1A <- ggplot(data %>% mutate(`TTE Measurement` = "Mean Cardiac Output"),
       aes(x = mean_values, y = differences, color = `TTE Measurement`)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = mean_diff, color = "blue", linewidth = 1) +
  geom_hline(yintercept = upper_limit, color = "red", linetype = "dashed") +
  geom_hline(yintercept = lower_limit, color = "red", linetype = "dashed") +
  labs(
    title = "Bland-Altman Plot (between-subject variance)",
    x = "Mean of Cardiac Output (TTE and Fick)",
    y = "Difference Between Cardiac Output (TTE - Fick)",
    tag = "A"
  ) +
  scale_color_manual(values = c("Mean Cardiac Output" = "grey30")) +
  scale_x_continuous(limits = c(3.5, 13), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-10, 10.5), expand = c(0, 0)) +
  theme_minimal() +
  theme(
    legend.position = "bottom"
  )

fig1A
```

```{r}
#| eval: false
fig1A <- ggplot(data %>% mutate(`Medición ECOTT` = "Promedio de GC"),
       aes(x = mean_values, y = differences, color = `Medición ECOTT`)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = mean_diff, color = "blue", linewidth = 1) +
  geom_hline(yintercept = upper_limit, color = "red", linetype = "dashed") +
  geom_hline(yintercept = lower_limit, color = "red", linetype = "dashed") +
  labs(
    title = "Gráfico de Bland-Altman (varianza entre sujetos)",
    x = "Promedio del Gasto Cardíaco (ECOTT y Fick)",
    y = "Diferencia entre el Gasto Cardíaco (ECOTT - Fick)",
    tag = "A"
  ) +
  scale_color_manual(values = c("Promedio de GC" = "grey30")) +
  scale_x_continuous(limits = c(3.5, 13), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-10, 10.5), expand = c(0, 0)) +
  theme_minimal() +
  theme(
    legend.position = "bottom"
  )

fig1A
```

{{< pagebreak >}}

#### Bland Altman-repeated measures (random effects for between-subject variance and within-subject variance)

```{r}
data_long <- data %>%
  pivot_longer(
    cols = starts_with("CO_TTE_"),  # Select the columns CO_TTE_1, CO_TTE_2, CO_TTE_3
    names_to = "TTE_measurement",
    values_to = "CO_TTE_individual"
  ) %>% 
  mutate(TTE_measurement = factor(
    str_extract(TTE_measurement, "\\d+"),
    levels = c("1", "2", "3")
    ))

# Calculate mean values and differences for each row
data_long <- data_long %>%
  mutate(
    mean_values = (CO_TTE_individual + cardiac_output_Fick) / 2,
    differences = CO_TTE_individual - cardiac_output_Fick
  )
```

```{r}
model_long <- lmer(
  differences ~ 1 + (1 | ID) + (1 | ID:time_point) + (1 | TTE_measurement),
  data = data_long
)
model_long_observer <- lmer(
  differences ~ 1 + (1 | ID) + (1 | ID:time_point) + (1 | TTE_measurement) + observer,
  data = data_long
)
anova(model_long, model_long_observer)
```

As before, the model with observer not significantly better, but the distribution of observations improves by including it. This, will include. 

```{r}
# Extract mean difference (fixed effect)
mean_diff_long <- fixef(model_long_observer)[1]  # Mean difference (fixed effect)

# Extract variance components
variance_components <- as.data.frame(VarCorr(model_long_observer))
var_id <- variance_components[variance_components$grp == "ID", "vcov"]  # Variance between participants
var_time_point <- variance_components[variance_components$grp == "ID:time_point", "vcov"]  # Variance between time points within participants
var_measurement <- variance_components[variance_components$grp == "TTE_measurement", "vcov"]  # Variance between measurements
residual_variance <- sigma(model_long_observer)^2  # Residual variance (measurement error)

# Compute total variability (sum of all variance components)
total_variance <- var_id + var_time_point + var_measurement + residual_variance

# Compute standard deviation of differences
sd_diff_long <- sqrt(total_variance)

# Compute 95% limits of agreement
upper_limit_long <- mean_diff_long + 1.96 * sd_diff_long
lower_limit_long <- mean_diff_long - 1.96 * sd_diff_long

# Test for systematic bias (null hypothesis: mean difference = 0)
se_mean_diff_long <- sqrt(diag(vcov(model_long_observer)))[1]  # Standard error of the fixed effect
z_statistic <- mean_diff_long / se_mean_diff_long
p_value <- 2 * (1 - pnorm(abs(z_statistic)))  # Two-tailed p-value
```

```{r}
summary(model_long_observer)
```

There was singularity in the prior model including a random effect for within-subject TTE measurements. Because this term is conceptually important to take into account the nested structure of the data, we will keep it in the model. Other alternatives would be to include it as a fixed effect, but this would not necessarily represent a meaningful variable to model. 

```{r}
# Bland-Altman plot for individual measurements
fig1B <- ggplot(data_long, aes(x = mean_values, y = differences, color = TTE_measurement)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = mean_diff_long, color = "blue", linewidth = 1) +
  geom_hline(yintercept = upper_limit_long, color = "red", linetype = "dashed") +
  geom_hline(yintercept = lower_limit_long, color = "red", linetype = "dashed") +
  labs(
    title = "Bland-Altman Plot (between and within-subject variance)",
    x = "Mean of Cardiac Output (TTE and Fick)",
    y = "Difference Between Cardiac Output (TTE - Fick)",
    color = "TTE Measurement",
    tag = "B"
  ) +
  scale_x_continuous(limits = c(3.5, 13), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-10, 10.5), expand = c(0, 0)) +
  scale_color_manual(
    values = c("1" = "royalblue", "2" = "green4", "3" = "orange2"),  # Set colors for the levels
  ) +
  theme_minimal() +   
  theme(
    legend.position = "bottom"
  )

fig1B
```

## Residuals and random effects diagnostics

```{r}
res <- resid(model_long_observer)

plot(fitted(model_long_observer), res,
     xlab = "Fitted values", ylab = "Residuals",
     main = "Residuals vs Fitted")
abline(h = 0, col = "red")
```

Residuals randomly distributed, no apparent patterns. 

```{r}
sim_res <- simulateResiduals(model_long_observer)
plot(sim_res)
```

Diagnostics form predicted residuals also show random distribution, with no heteroskedasticity or patterns, supporting lineraity assumption. No evidence of influential outliers. 

```{r}
ranef_vals <- ranef(model_long_observer)
dotplot(ranef(model_long_observer, condVar = TRUE))
```

Simetric distribution, with bell curve shape, not showing strong outliers. Random effects for ID and ID:time_point relevant. For TTE measurement, no variation seen as expected due to singularity, therefore this term is not relevant for the model. As mentioned earlier, it was kept as it is considered conceptually relevant. Conclusion is that TTE measurements are quite consistent among each time point within participant.  

```{r}
#| eval: false
# Bland-Altman para medidas individuales
fig1B <- ggplot(data_long, aes(x = mean_values, y = differences, color = TTE_measurement)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = mean_diff_long, color = "blue", linewidth = 1) +
  geom_hline(yintercept = upper_limit_long, color = "red", linetype = "dashed") +
  geom_hline(yintercept = lower_limit_long, color = "red", linetype = "dashed") +
  labs(
    title = "Gráfico de Bland-Altman (varianza entre sujetos y fija dentro del sujeto)",
    x = "Promedio del Gasto Cardíaco (ECOTT y Fick)",
    y = "Diferencia entre el Gasto Cardíaco (ECOTT - Fick)",
    color = "Medición ECOTT",
    tag = "B"
  ) +
  scale_x_continuous(limits = c(3.5, 13), expand = c(0, 0)) +
  scale_y_continuous(limits = c(-10, 10.5), expand = c(0, 0)) +
  scale_color_manual(
    values = c("1" = "royalblue", "2" = "green4", "3" = "orange2"),  # Set colors for the levels
  ) +
  theme_minimal() +   
  theme(
    legend.position = "bottom"
  )
```

{{< pagebreak >}}

# Mean absolute difference (MAD)

```{r}
# Mean Absolute Difference
MAD <- mean(abs(data$cardiac_output_TTE - data$cardiac_output_Fick))

# Add 95% confidence interval
MAD_interval <- MAD + c(-1, 1) * 1.96 * sd(data$cardiac_output_TTE - data$cardiac_output_Fick) / sqrt(nrow(data))
```

The MAD for cardiac output is `r MAD %>% round(1)` (95% CI: `r MAD_interval[1] %>% round(1)` to `r MAD_interval[2] %>% round(1)`).

# Mean absolute percentage error (MAPE) and precision of Fick method

```{r}
mape_point <- mean(abs((data$cardiac_output_TTE - data$cardiac_output_Fick) / 
                      data$cardiac_output_TTE)) * 100

# Bootstrap with boot package 
mape_boot <- function(data, indices) {
  sample_data <- data[indices, ]
  mape <- mean(abs((sample_data$cardiac_output_TTE - sample_data$cardiac_output_Fick) / 
                   sample_data$cardiac_output_TTE)) * 100
  return(mape)
}

# Perform bootstrap with boot package
set.seed(123)
boot_results <- boot(data = data, 
                    statistic = mape_boot, 
                    R = 10000)

# Calculate 95% CI using different methods from boot package
ci_basic <- boot.ci(boot_results, type = "basic")
ci_perc <- boot.ci(boot_results, type = "perc")
ci_bca <- boot.ci(boot_results, type = "bca")
```

```{r}
# Extract precisiona and 95% CI
precisiona <- mean(data$CE_TTE_CO) * 2 # Point estimate
precisiona_lower <- ci_bca_CE$bca[4] * 2 # Lower bound
precisiona_upper <- ci_bca_CE$bca[5] * 2 # Upper bound

# Extract PEa-b and its 95% CI from the global environment
PEa_b <- mape_point # Point estimate
PEa_b_lower <- ci_bca$bca[4] # Lower bound
PEa_b_upper <- ci_bca$bca[5] # Upper bound

# Function to calculate precisionb
calculate_precisionb <- function(PEa_b, precisiona) {
  sqrt((PEa_b)^2 - (precisiona)^2)
}

# Calculate precisionb (point estimate)
precisionb <- calculate_precisionb(PEa_b, precisiona)

# Sensitivity analysis: lower and upper bounds
precisionb_lower <- calculate_precisionb(PEa_b_lower, precisiona_upper)
precisionb_upper <- calculate_precisionb(PEa_b_upper, precisiona_lower)

# Print results
cat("Precisionb (point estimate):", round(precisionb, 2), "%\n")
cat("Precisionb (95% CI):", round(precisionb_lower, 2), "-", round(precisionb_upper, 2), "%\n")

```


{{< pagebreak >}}

# Summary

The mean cardiac output with TTE was `r mean(data$cardiac_output_TTE) %>% round(2)` (95% CI: `r ci_bca_mean_CO_TTE$bca[4] %>% round(2)` to `r ci_bca_mean_CO_TTE$bca[5] %>% round(2)`) L/min, and `r mean(data$cardiac_output_Fick) %>% round(2)` L/min (95% CI: `r ci_bca_mean_CO_Fick$bca[4] %>% round(2)` to `r ci_bca_mean_CO_Fick$bca[5] %>% round(2)`) for the Fick method. The correlation between the two methods was rho = `r correlation$estimate %>% round(2)` (95% CI: `r correlation$conf.int[1] %>% round(2)` to `r correlation$conf.int[2] %>% round(2)`, p=`r correlation$p.value %>% round(3)`). In a linear mixed model with random patient slopes, there was a change in Fick CO of `r linear_mixed_model_obs_fixed@beta[2] %>% round(3)` (95% CI: `r linear_mixed_model_CI["cardiac_output_TTE",1] %>% round(3)` to `r linear_mixed_model_CI["cardiac_output_TTE",2] %>% round(3)`) L/min for each unit change in mean TTE CO. The ICC between TCE and Fick CO `r icc$value %>% round(2)` (95% CI: `r icc$lbound %>% round(2)` to `r icc$ubound %>% round(2)`). 

The mean absolute difference in CO between TTE and Fick was `r MAD %>% round(2)` (95% CI: `r MAD_interval[1] %>% round(1)` to `r MAD_interval[2] %>% round(1)`) L/min. The coefficient of variation for an individual measurement of TTE was `r cv_TTE %>% round(1)`% and `r cv_Fick %>% round(2)`% for Fick. The mean CV of TTE for the repeated measurements per patient was `r mean(data$CV_TTE_CO_row) %>% round(1)`% (95% CI: `r ci_bca_CV$bca[4] %>% round(1)` to `r ci_bca_CV$bca[5] %>% round(1)`) and the CE was `r mean(data$CE_TTE_CO) %>% round(1)`% (95% CI: `r ci_bca_CE$bca[4] %>% round(1)` to `r ci_bca_CE$bca[5] %>% round(1)`), corresponding to a precision of `r precisiona %>% round(1)`% (95% CI: `r precisiona_lower %>% round(1)` to `r precisiona_upper %>% round(1)`). The MAPE of the Fick method compared to TTE was `r mape_point %>% round(1)`% (95% CI: `r ci_bca$bca[4] %>% round(1)` - `r ci_bca$bca[5] %>% round(1)`). The precision of the Fick method was `r precisionb %>% round(2)`% (95% CI: `r precisionb_lower %>% round(2)` to `r precisionb_upper %>% round(2)`). The LSC was `r (precisiona * sqrt(2)) %>% round(1)`% (95% CI: `r (precisiona_lower * sqrt(2)) %>% round(1)` to `r (precisiona_upper * sqrt(2)) %>% round(1)`) for TTE and `r (precisionb * sqrt(2)) %>% round(1)`% (95% CI: `r (precisionb_lower * sqrt(2)) %>% round(1)` to `r (precisionb_upper * sqrt(2)) %>% round(1)`) for the Fick method.

**Figure 1** shows the Bland-Altman plot for the repeated measures model with random effects for between-subject variance (Figure1A) and within-subject variance (Figure1B). The mean difference (systematic bias) between TTE and Fick CO was `r mean_diff_long %>% round(2)` (95% CI: `r (mean_diff_long - 1.96 * se_mean_diff_long) %>% round(2)` to `r (mean_diff_long + 1.96 * se_mean_diff_long) %>% round(2)`, p = `r p_value %>% round(3)`) L/min, with 95% limits of agreement of `r lower_limit_long %>% round(2)` to `r upper_limit_long %>% round(2)` L/min. 

```{r}
ggsave(
  filename = file.path(figfolder, "Figure1.tiff"),
  plot = arrangeGrob(fig1A, fig1B, nrow = 2),
  width = 7, height = 10, dpi = 300, bg = "white"
)
```


{{< pagebreak >}}

# References

::: {#refs}
:::

{{< pagebreak >}}

# Package References

```{r}
#| output: asis 
report::cite_packages(session)
```

```{r}
#| include: false

# Run this chunk if you wish to clear your environment and unload packages.

pacman::p_unload(negate = TRUE)

rm(list = ls())
```
